{"version":3,"sources":["../node_modules/@graphiql/react/dist/javascript.es.js"],"names":["__webpack_require__","r","__webpack_exports__","d","javascript$1","_mergeNamespaces2","_Users_creimers_projects_graphene_graphiql_explorer_graphene_graphiql_explorer_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__","_codemirror_es_js__WEBPACK_IMPORTED_MODULE_1__","__defProp","Object","defineProperty","__name","target","value","configurable","_mergeNamespaces","n","m","forEach","e","Array","isArray","keys","k","getOwnPropertyDescriptor","get","enumerable","freeze","javascript$2","exports","mod","CodeMirror","defineMode","config","parserConfig","type","content","indentUnit","statementIndent","jsonldMode","jsonld","jsonMode","json","trackScope","isTS","typescript","wordRE","wordCharacters","keywords","kw","type2","style","A","B","C","D","operator","atom","if","while","with","else","do","try","finally","return","break","continue","new","delete","void","throw","debugger","var","const","let","function","catch","for","switch","case","default","in","typeof","instanceof","true","false","null","undefined","NaN","Infinity","this","class","super","yield","export","import","extends","await","isOperatorChar","isJsonldKeyword","readRegexp","stream","next","escaped","inSet","ret","tp","cont2","tokenBase","state","ch","tokenize","tokenString","match","test","eat","tokenComment","skipToEnd","expressionAllowed","current","tokenQuasi","peek","eatWhile","string","slice","start","lexical","word","lastType","propertyIsEnumerable","quote","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","indexOf","exec","index","depth","sawSomething","pos","charAt","bracket","atomicTypes","number","variable","regexp","jsonld-keyword","JSLexical","indented","column","align","prev","info","inScope","varname","v","localVars","name","cx2","context","vars","parseJS","content2","cc","cx","marked","hasOwnProperty","combinator","length","pop","expression","statement","lex","pass","i","arguments","push","cont","apply","inList","list","register","block","newContext","registerVarScoped","Var","globalVars","inner","Context","isModifier","block2","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","result","indent","outer","poplex","expect","wanted","exp","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","className","enumdef","typename","typeexpr","pattern","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","me","expr","property","backUp","continueQuasi","targetNoComma","maybeTypeArgs","_","getterSetter","afterprop","maybetype","what","end","sep","proceed","type3","value2","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","isInterface","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","isContinuedStatement","textAfter","startState","basecolumn","token","sol","indentation","eatSpace","Pass","top","firstChar","c","closing","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","blockCommentContinue","lineComment","fold","closeBrackets","helperType","skipExpression","StringStream","registerHelper","defineMIME","javascript","__proto__","Symbol","toStringTag"],"mappings":"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","file":"static/js/24.0e86c741.chunk.js","sourcesContent":["import _defineProperty from \"/Users/creimers/projects/graphene-graphiql-explorer/graphene_graphiql_explorer/src/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _mergeNamespaces2;\n\nvar __defProp = Object.defineProperty;\n\nvar __name = function __name(target, value) {\n  return __defProp(target, \"name\", {\n    value: value,\n    configurable: true\n  });\n};\n\nimport { a as codemirror } from \"./codemirror.es.js\";\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function (e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function get() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n\n__name(_mergeNamespaces, \"_mergeNamespaces\");\n\nvar javascript$2 = {\n  exports: {}\n};\n\n(function (module, exports) {\n  (function (mod) {\n    mod(codemirror.exports);\n  })(function (CodeMirror) {\n    CodeMirror.defineMode(\"javascript\", function (config, parserConfig) {\n      var indentUnit = config.indentUnit;\n      var statementIndent = parserConfig.statementIndent;\n      var jsonldMode = parserConfig.jsonld;\n      var jsonMode = parserConfig.json || jsonldMode;\n      var trackScope = parserConfig.trackScope !== false;\n      var isTS = parserConfig.typescript;\n      var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n      var keywords = function () {\n        function kw(type2) {\n          return {\n            type: type2,\n            style: \"keyword\"\n          };\n        }\n\n        __name(kw, \"kw\");\n\n        var A = kw(\"keyword a\"),\n            B = kw(\"keyword b\"),\n            C = kw(\"keyword c\"),\n            D = kw(\"keyword d\");\n        var operator = kw(\"operator\"),\n            atom = {\n          type: \"atom\",\n          style: \"atom\"\n        };\n        return {\n          \"if\": kw(\"if\"),\n          \"while\": A,\n          \"with\": A,\n          \"else\": B,\n          \"do\": B,\n          \"try\": B,\n          \"finally\": B,\n          \"return\": D,\n          \"break\": D,\n          \"continue\": D,\n          \"new\": kw(\"new\"),\n          \"delete\": C,\n          \"void\": C,\n          \"throw\": C,\n          \"debugger\": kw(\"debugger\"),\n          \"var\": kw(\"var\"),\n          \"const\": kw(\"var\"),\n          \"let\": kw(\"var\"),\n          \"function\": kw(\"function\"),\n          \"catch\": kw(\"catch\"),\n          \"for\": kw(\"for\"),\n          \"switch\": kw(\"switch\"),\n          \"case\": kw(\"case\"),\n          \"default\": kw(\"default\"),\n          \"in\": operator,\n          \"typeof\": operator,\n          \"instanceof\": operator,\n          \"true\": atom,\n          \"false\": atom,\n          \"null\": atom,\n          \"undefined\": atom,\n          \"NaN\": atom,\n          \"Infinity\": atom,\n          \"this\": kw(\"this\"),\n          \"class\": kw(\"class\"),\n          \"super\": kw(\"atom\"),\n          \"yield\": C,\n          \"export\": kw(\"export\"),\n          \"import\": kw(\"import\"),\n          \"extends\": C,\n          \"await\": C\n        };\n      }();\n\n      var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n      function readRegexp(stream) {\n        var escaped = false,\n            next,\n            inSet = false;\n\n        while ((next = stream.next()) != null) {\n          if (!escaped) {\n            if (next == \"/\" && !inSet) return;\n            if (next == \"[\") inSet = true;else if (inSet && next == \"]\") inSet = false;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n      }\n\n      __name(readRegexp, \"readRegexp\");\n\n      var type, content;\n\n      function ret(tp, style, cont2) {\n        type = tp;\n        content = cont2;\n        return style;\n      }\n\n      __name(ret, \"ret\");\n\n      function tokenBase(stream, state) {\n        var ch = stream.next();\n\n        if (ch == '\"' || ch == \"'\") {\n          state.tokenize = tokenString(ch);\n          return state.tokenize(stream, state);\n        } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n          return ret(\"number\", \"number\");\n        } else if (ch == \".\" && stream.match(\"..\")) {\n          return ret(\"spread\", \"meta\");\n        } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n          return ret(ch);\n        } else if (ch == \"=\" && stream.eat(\">\")) {\n          return ret(\"=>\", \"operator\");\n        } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n          return ret(\"number\", \"number\");\n        } else if (/\\d/.test(ch)) {\n          stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n          return ret(\"number\", \"number\");\n        } else if (ch == \"/\") {\n          if (stream.eat(\"*\")) {\n            state.tokenize = tokenComment;\n            return tokenComment(stream, state);\n          } else if (stream.eat(\"/\")) {\n            stream.skipToEnd();\n            return ret(\"comment\", \"comment\");\n          } else if (expressionAllowed(stream, state, 1)) {\n            readRegexp(stream);\n            stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n            return ret(\"regexp\", \"string-2\");\n          } else {\n            stream.eat(\"=\");\n            return ret(\"operator\", \"operator\", stream.current());\n          }\n        } else if (ch == \"`\") {\n          state.tokenize = tokenQuasi;\n          return tokenQuasi(stream, state);\n        } else if (ch == \"#\" && stream.peek() == \"!\") {\n          stream.skipToEnd();\n          return ret(\"meta\", \"meta\");\n        } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n          return ret(\"variable\", \"property\");\n        } else if (ch == \"<\" && stream.match(\"!--\") || ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start))) {\n          stream.skipToEnd();\n          return ret(\"comment\", \"comment\");\n        } else if (isOperatorChar.test(ch)) {\n          if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n            if (stream.eat(\"=\")) {\n              if (ch == \"!\" || ch == \"=\") stream.eat(\"=\");\n            } else if (/[<>*+\\-|&?]/.test(ch)) {\n              stream.eat(ch);\n              if (ch == \">\") stream.eat(ch);\n            }\n          }\n\n          if (ch == \"?\" && stream.eat(\".\")) return ret(\".\");\n          return ret(\"operator\", \"operator\", stream.current());\n        } else if (wordRE.test(ch)) {\n          stream.eatWhile(wordRE);\n          var word = stream.current();\n\n          if (state.lastType != \".\") {\n            if (keywords.propertyIsEnumerable(word)) {\n              var kw = keywords[word];\n              return ret(kw.type, kw.style, word);\n            }\n\n            if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false)) return ret(\"async\", \"keyword\", word);\n          }\n\n          return ret(\"variable\", \"variable\", word);\n        }\n      }\n\n      __name(tokenBase, \"tokenBase\");\n\n      function tokenString(quote) {\n        return function (stream, state) {\n          var escaped = false,\n              next;\n\n          if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)) {\n            state.tokenize = tokenBase;\n            return ret(\"jsonld-keyword\", \"meta\");\n          }\n\n          while ((next = stream.next()) != null) {\n            if (next == quote && !escaped) break;\n            escaped = !escaped && next == \"\\\\\";\n          }\n\n          if (!escaped) state.tokenize = tokenBase;\n          return ret(\"string\", \"string\");\n        };\n      }\n\n      __name(tokenString, \"tokenString\");\n\n      function tokenComment(stream, state) {\n        var maybeEnd = false,\n            ch;\n\n        while (ch = stream.next()) {\n          if (ch == \"/\" && maybeEnd) {\n            state.tokenize = tokenBase;\n            break;\n          }\n\n          maybeEnd = ch == \"*\";\n        }\n\n        return ret(\"comment\", \"comment\");\n      }\n\n      __name(tokenComment, \"tokenComment\");\n\n      function tokenQuasi(stream, state) {\n        var escaped = false,\n            next;\n\n        while ((next = stream.next()) != null) {\n          if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n            state.tokenize = tokenBase;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        return ret(\"quasi\", \"string-2\", stream.current());\n      }\n\n      __name(tokenQuasi, \"tokenQuasi\");\n\n      var brackets = \"([{}])\";\n\n      function findFatArrow(stream, state) {\n        if (state.fatArrowAt) state.fatArrowAt = null;\n        var arrow = stream.string.indexOf(\"=>\", stream.start);\n        if (arrow < 0) return;\n\n        if (isTS) {\n          var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow));\n          if (m) arrow = m.index;\n        }\n\n        var depth = 0,\n            sawSomething = false;\n\n        for (var pos = arrow - 1; pos >= 0; --pos) {\n          var ch = stream.string.charAt(pos);\n          var bracket = brackets.indexOf(ch);\n\n          if (bracket >= 0 && bracket < 3) {\n            if (!depth) {\n              ++pos;\n              break;\n            }\n\n            if (--depth == 0) {\n              if (ch == \"(\") sawSomething = true;\n              break;\n            }\n          } else if (bracket >= 3 && bracket < 6) {\n            ++depth;\n          } else if (wordRE.test(ch)) {\n            sawSomething = true;\n          } else if (/[\"'\\/`]/.test(ch)) {\n            for (;; --pos) {\n              if (pos == 0) return;\n              var next = stream.string.charAt(pos - 1);\n\n              if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") {\n                pos--;\n                break;\n              }\n            }\n          } else if (sawSomething && !depth) {\n            ++pos;\n            break;\n          }\n        }\n\n        if (sawSomething && !depth) state.fatArrowAt = pos;\n      }\n\n      __name(findFatArrow, \"findFatArrow\");\n\n      var atomicTypes = {\n        \"atom\": true,\n        \"number\": true,\n        \"variable\": true,\n        \"string\": true,\n        \"regexp\": true,\n        \"this\": true,\n        \"import\": true,\n        \"jsonld-keyword\": true\n      };\n\n      function JSLexical(indented, column, type2, align, prev, info) {\n        this.indented = indented;\n        this.column = column;\n        this.type = type2;\n        this.prev = prev;\n        this.info = info;\n        if (align != null) this.align = align;\n      }\n\n      __name(JSLexical, \"JSLexical\");\n\n      function inScope(state, varname) {\n        if (!trackScope) return false;\n\n        for (var v = state.localVars; v; v = v.next) {\n          if (v.name == varname) return true;\n        }\n\n        for (var cx2 = state.context; cx2; cx2 = cx2.prev) {\n          for (var v = cx2.vars; v; v = v.next) {\n            if (v.name == varname) return true;\n          }\n        }\n      }\n\n      __name(inScope, \"inScope\");\n\n      function parseJS(state, style, type2, content2, stream) {\n        var cc = state.cc;\n        cx.state = state;\n        cx.stream = stream;\n        cx.marked = null, cx.cc = cc;\n        cx.style = style;\n        if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n\n        while (true) {\n          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n\n          if (combinator(type2, content2)) {\n            while (cc.length && cc[cc.length - 1].lex) {\n              cc.pop()();\n            }\n\n            if (cx.marked) return cx.marked;\n            if (type2 == \"variable\" && inScope(state, content2)) return \"variable-2\";\n            return style;\n          }\n        }\n      }\n\n      __name(parseJS, \"parseJS\");\n\n      var cx = {\n        state: null,\n        column: null,\n        marked: null,\n        cc: null\n      };\n\n      function pass() {\n        for (var i = arguments.length - 1; i >= 0; i--) {\n          cx.cc.push(arguments[i]);\n        }\n      }\n\n      __name(pass, \"pass\");\n\n      function cont() {\n        pass.apply(null, arguments);\n        return true;\n      }\n\n      __name(cont, \"cont\");\n\n      function inList(name, list) {\n        for (var v = list; v; v = v.next) {\n          if (v.name == name) return true;\n        }\n\n        return false;\n      }\n\n      __name(inList, \"inList\");\n\n      function register(varname) {\n        var state = cx.state;\n        cx.marked = \"def\";\n        if (!trackScope) return;\n\n        if (state.context) {\n          if (state.lexical.info == \"var\" && state.context && state.context.block) {\n            var newContext = registerVarScoped(varname, state.context);\n\n            if (newContext != null) {\n              state.context = newContext;\n              return;\n            }\n          } else if (!inList(varname, state.localVars)) {\n            state.localVars = new Var(varname, state.localVars);\n            return;\n          }\n        }\n\n        if (parserConfig.globalVars && !inList(varname, state.globalVars)) state.globalVars = new Var(varname, state.globalVars);\n      }\n\n      __name(register, \"register\");\n\n      function registerVarScoped(varname, context) {\n        if (!context) {\n          return null;\n        } else if (context.block) {\n          var inner = registerVarScoped(varname, context.prev);\n          if (!inner) return null;\n          if (inner == context.prev) return context;\n          return new Context(inner, context.vars, true);\n        } else if (inList(varname, context.vars)) {\n          return context;\n        } else {\n          return new Context(context.prev, new Var(varname, context.vars), false);\n        }\n      }\n\n      __name(registerVarScoped, \"registerVarScoped\");\n\n      function isModifier(name) {\n        return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\";\n      }\n\n      __name(isModifier, \"isModifier\");\n\n      function Context(prev, vars, block2) {\n        this.prev = prev;\n        this.vars = vars;\n        this.block = block2;\n      }\n\n      __name(Context, \"Context\");\n\n      function Var(name, next) {\n        this.name = name;\n        this.next = next;\n      }\n\n      __name(Var, \"Var\");\n\n      var defaultVars = new Var(\"this\", new Var(\"arguments\", null));\n\n      function pushcontext() {\n        cx.state.context = new Context(cx.state.context, cx.state.localVars, false);\n        cx.state.localVars = defaultVars;\n      }\n\n      __name(pushcontext, \"pushcontext\");\n\n      function pushblockcontext() {\n        cx.state.context = new Context(cx.state.context, cx.state.localVars, true);\n        cx.state.localVars = null;\n      }\n\n      __name(pushblockcontext, \"pushblockcontext\");\n\n      pushcontext.lex = pushblockcontext.lex = true;\n\n      function popcontext() {\n        cx.state.localVars = cx.state.context.vars;\n        cx.state.context = cx.state.context.prev;\n      }\n\n      __name(popcontext, \"popcontext\");\n\n      popcontext.lex = true;\n\n      function pushlex(type2, info) {\n        var result =\n        /* @__PURE__ */\n        __name(function () {\n          var state = cx.state,\n              indent = state.indented;\n          if (state.lexical.type == \"stat\") indent = state.lexical.indented;else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev) {\n            indent = outer.indented;\n          }\n          state.lexical = new JSLexical(indent, cx.stream.column(), type2, null, state.lexical, info);\n        }, \"result\");\n\n        result.lex = true;\n        return result;\n      }\n\n      __name(pushlex, \"pushlex\");\n\n      function poplex() {\n        var state = cx.state;\n\n        if (state.lexical.prev) {\n          if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n          state.lexical = state.lexical.prev;\n        }\n      }\n\n      __name(poplex, \"poplex\");\n\n      poplex.lex = true;\n\n      function expect(wanted) {\n        function exp(type2) {\n          if (type2 == wanted) return cont();else if (wanted == \";\" || type2 == \"}\" || type2 == \")\" || type2 == \"]\") return pass();else return cont(exp);\n        }\n\n        __name(exp, \"exp\");\n\n        return exp;\n      }\n\n      __name(expect, \"expect\");\n\n      function statement(type2, value) {\n        if (type2 == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n        if (type2 == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n        if (type2 == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n        if (type2 == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n        if (type2 == \"debugger\") return cont(expect(\";\"));\n        if (type2 == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n        if (type2 == \";\") return cont();\n\n        if (type2 == \"if\") {\n          if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex) cx.state.cc.pop()();\n          return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n        }\n\n        if (type2 == \"function\") return cont(functiondef);\n        if (type2 == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n\n        if (type2 == \"class\" || isTS && value == \"interface\") {\n          cx.marked = \"keyword\";\n          return cont(pushlex(\"form\", type2 == \"class\" ? type2 : value), className, poplex);\n        }\n\n        if (type2 == \"variable\") {\n          if (isTS && value == \"declare\") {\n            cx.marked = \"keyword\";\n            return cont(statement);\n          } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n            cx.marked = \"keyword\";\n            if (value == \"enum\") return cont(enumdef);else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex);\n          } else if (isTS && value == \"namespace\") {\n            cx.marked = \"keyword\";\n            return cont(pushlex(\"form\"), expression, statement, poplex);\n          } else if (isTS && value == \"abstract\") {\n            cx.marked = \"keyword\";\n            return cont(statement);\n          } else {\n            return cont(pushlex(\"stat\"), maybelabel);\n          }\n        }\n\n        if (type2 == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext, block, poplex, poplex, popcontext);\n        if (type2 == \"case\") return cont(expression, expect(\":\"));\n        if (type2 == \"default\") return cont(expect(\":\"));\n        if (type2 == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n        if (type2 == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n        if (type2 == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n        if (type2 == \"async\") return cont(statement);\n        if (value == \"@\") return cont(expression, statement);\n        return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n      }\n\n      __name(statement, \"statement\");\n\n      function maybeCatchBinding(type2) {\n        if (type2 == \"(\") return cont(funarg, expect(\")\"));\n      }\n\n      __name(maybeCatchBinding, \"maybeCatchBinding\");\n\n      function expression(type2, value) {\n        return expressionInner(type2, value, false);\n      }\n\n      __name(expression, \"expression\");\n\n      function expressionNoComma(type2, value) {\n        return expressionInner(type2, value, true);\n      }\n\n      __name(expressionNoComma, \"expressionNoComma\");\n\n      function parenExpr(type2) {\n        if (type2 != \"(\") return pass();\n        return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex);\n      }\n\n      __name(parenExpr, \"parenExpr\");\n\n      function expressionInner(type2, value, noComma) {\n        if (cx.state.fatArrowAt == cx.stream.start) {\n          var body = noComma ? arrowBodyNoComma : arrowBody;\n          if (type2 == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);else if (type2 == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n        }\n\n        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n        if (atomicTypes.hasOwnProperty(type2)) return cont(maybeop);\n        if (type2 == \"function\") return cont(functiondef, maybeop);\n\n        if (type2 == \"class\" || isTS && value == \"interface\") {\n          cx.marked = \"keyword\";\n          return cont(pushlex(\"form\"), classExpression, poplex);\n        }\n\n        if (type2 == \"keyword c\" || type2 == \"async\") return cont(noComma ? expressionNoComma : expression);\n        if (type2 == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n        if (type2 == \"operator\" || type2 == \"spread\") return cont(noComma ? expressionNoComma : expression);\n        if (type2 == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n        if (type2 == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n        if (type2 == \"quasi\") return pass(quasi, maybeop);\n        if (type2 == \"new\") return cont(maybeTarget(noComma));\n        return cont();\n      }\n\n      __name(expressionInner, \"expressionInner\");\n\n      function maybeexpression(type2) {\n        if (type2.match(/[;\\}\\)\\],]/)) return pass();\n        return pass(expression);\n      }\n\n      __name(maybeexpression, \"maybeexpression\");\n\n      function maybeoperatorComma(type2, value) {\n        if (type2 == \",\") return cont(maybeexpression);\n        return maybeoperatorNoComma(type2, value, false);\n      }\n\n      __name(maybeoperatorComma, \"maybeoperatorComma\");\n\n      function maybeoperatorNoComma(type2, value, noComma) {\n        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n        var expr = noComma == false ? expression : expressionNoComma;\n        if (type2 == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n\n        if (type2 == \"operator\") {\n          if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n          if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false)) return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n          if (value == \"?\") return cont(expression, expect(\":\"), expr);\n          return cont(expr);\n        }\n\n        if (type2 == \"quasi\") {\n          return pass(quasi, me);\n        }\n\n        if (type2 == \";\") return;\n        if (type2 == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n        if (type2 == \".\") return cont(property, me);\n        if (type2 == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n\n        if (isTS && value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(typeexpr, me);\n        }\n\n        if (type2 == \"regexp\") {\n          cx.state.lastType = cx.marked = \"operator\";\n          cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);\n          return cont(expr);\n        }\n      }\n\n      __name(maybeoperatorNoComma, \"maybeoperatorNoComma\");\n\n      function quasi(type2, value) {\n        if (type2 != \"quasi\") return pass();\n        if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n        return cont(maybeexpression, continueQuasi);\n      }\n\n      __name(quasi, \"quasi\");\n\n      function continueQuasi(type2) {\n        if (type2 == \"}\") {\n          cx.marked = \"string-2\";\n          cx.state.tokenize = tokenQuasi;\n          return cont(quasi);\n        }\n      }\n\n      __name(continueQuasi, \"continueQuasi\");\n\n      function arrowBody(type2) {\n        findFatArrow(cx.stream, cx.state);\n        return pass(type2 == \"{\" ? statement : expression);\n      }\n\n      __name(arrowBody, \"arrowBody\");\n\n      function arrowBodyNoComma(type2) {\n        findFatArrow(cx.stream, cx.state);\n        return pass(type2 == \"{\" ? statement : expressionNoComma);\n      }\n\n      __name(arrowBodyNoComma, \"arrowBodyNoComma\");\n\n      function maybeTarget(noComma) {\n        return function (type2) {\n          if (type2 == \".\") return cont(noComma ? targetNoComma : target);else if (type2 == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);else return pass(noComma ? expressionNoComma : expression);\n        };\n      }\n\n      __name(maybeTarget, \"maybeTarget\");\n\n      function target(_, value) {\n        if (value == \"target\") {\n          cx.marked = \"keyword\";\n          return cont(maybeoperatorComma);\n        }\n      }\n\n      __name(target, \"target\");\n\n      function targetNoComma(_, value) {\n        if (value == \"target\") {\n          cx.marked = \"keyword\";\n          return cont(maybeoperatorNoComma);\n        }\n      }\n\n      __name(targetNoComma, \"targetNoComma\");\n\n      function maybelabel(type2) {\n        if (type2 == \":\") return cont(poplex, statement);\n        return pass(maybeoperatorComma, expect(\";\"), poplex);\n      }\n\n      __name(maybelabel, \"maybelabel\");\n\n      function property(type2) {\n        if (type2 == \"variable\") {\n          cx.marked = \"property\";\n          return cont();\n        }\n      }\n\n      __name(property, \"property\");\n\n      function objprop(type2, value) {\n        if (type2 == \"async\") {\n          cx.marked = \"property\";\n          return cont(objprop);\n        } else if (type2 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          if (value == \"get\" || value == \"set\") return cont(getterSetter);\n          var m;\n          if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false))) cx.state.fatArrowAt = cx.stream.pos + m[0].length;\n          return cont(afterprop);\n        } else if (type2 == \"number\" || type2 == \"string\") {\n          cx.marked = jsonldMode ? \"property\" : cx.style + \" property\";\n          return cont(afterprop);\n        } else if (type2 == \"jsonld-keyword\") {\n          return cont(afterprop);\n        } else if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(objprop);\n        } else if (type2 == \"[\") {\n          return cont(expression, maybetype, expect(\"]\"), afterprop);\n        } else if (type2 == \"spread\") {\n          return cont(expressionNoComma, afterprop);\n        } else if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(objprop);\n        } else if (type2 == \":\") {\n          return pass(afterprop);\n        }\n      }\n\n      __name(objprop, \"objprop\");\n\n      function getterSetter(type2) {\n        if (type2 != \"variable\") return pass(afterprop);\n        cx.marked = \"property\";\n        return cont(functiondef);\n      }\n\n      __name(getterSetter, \"getterSetter\");\n\n      function afterprop(type2) {\n        if (type2 == \":\") return cont(expressionNoComma);\n        if (type2 == \"(\") return pass(functiondef);\n      }\n\n      __name(afterprop, \"afterprop\");\n\n      function commasep(what, end, sep) {\n        function proceed(type2, value) {\n          if (sep ? sep.indexOf(type2) > -1 : type2 == \",\") {\n            var lex = cx.state.lexical;\n            if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n            return cont(function (type3, value2) {\n              if (type3 == end || value2 == end) return pass();\n              return pass(what);\n            }, proceed);\n          }\n\n          if (type2 == end || value == end) return cont();\n          if (sep && sep.indexOf(\";\") > -1) return pass(what);\n          return cont(expect(end));\n        }\n\n        __name(proceed, \"proceed\");\n\n        return function (type2, value) {\n          if (type2 == end || value == end) return cont();\n          return pass(what, proceed);\n        };\n      }\n\n      __name(commasep, \"commasep\");\n\n      function contCommasep(what, end, info) {\n        for (var i = 3; i < arguments.length; i++) {\n          cx.cc.push(arguments[i]);\n        }\n\n        return cont(pushlex(end, info), commasep(what, end), poplex);\n      }\n\n      __name(contCommasep, \"contCommasep\");\n\n      function block(type2) {\n        if (type2 == \"}\") return cont();\n        return pass(statement, block);\n      }\n\n      __name(block, \"block\");\n\n      function maybetype(type2, value) {\n        if (isTS) {\n          if (type2 == \":\") return cont(typeexpr);\n          if (value == \"?\") return cont(maybetype);\n        }\n      }\n\n      __name(maybetype, \"maybetype\");\n\n      function maybetypeOrIn(type2, value) {\n        if (isTS && (type2 == \":\" || value == \"in\")) return cont(typeexpr);\n      }\n\n      __name(maybetypeOrIn, \"maybetypeOrIn\");\n\n      function mayberettype(type2) {\n        if (isTS && type2 == \":\") {\n          if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr);else return cont(typeexpr);\n        }\n      }\n\n      __name(mayberettype, \"mayberettype\");\n\n      function isKW(_, value) {\n        if (value == \"is\") {\n          cx.marked = \"keyword\";\n          return cont();\n        }\n      }\n\n      __name(isKW, \"isKW\");\n\n      function typeexpr(type2, value) {\n        if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n          cx.marked = \"keyword\";\n          return cont(value == \"typeof\" ? expressionNoComma : typeexpr);\n        }\n\n        if (type2 == \"variable\" || value == \"void\") {\n          cx.marked = \"type\";\n          return cont(afterType);\n        }\n\n        if (value == \"|\" || value == \"&\") return cont(typeexpr);\n        if (type2 == \"string\" || type2 == \"number\" || type2 == \"atom\") return cont(afterType);\n        if (type2 == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType);\n        if (type2 == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType);\n        if (type2 == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType);\n        if (type2 == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr);\n\n        if (type2 == \"quasi\") {\n          return pass(quasiType, afterType);\n        }\n      }\n\n      __name(typeexpr, \"typeexpr\");\n\n      function maybeReturnType(type2) {\n        if (type2 == \"=>\") return cont(typeexpr);\n      }\n\n      __name(maybeReturnType, \"maybeReturnType\");\n\n      function typeprops(type2) {\n        if (type2.match(/[\\}\\)\\]]/)) return cont();\n        if (type2 == \",\" || type2 == \";\") return cont(typeprops);\n        return pass(typeprop, typeprops);\n      }\n\n      __name(typeprops, \"typeprops\");\n\n      function typeprop(type2, value) {\n        if (type2 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          return cont(typeprop);\n        } else if (value == \"?\" || type2 == \"number\" || type2 == \"string\") {\n          return cont(typeprop);\n        } else if (type2 == \":\") {\n          return cont(typeexpr);\n        } else if (type2 == \"[\") {\n          return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop);\n        } else if (type2 == \"(\") {\n          return pass(functiondecl, typeprop);\n        } else if (!type2.match(/[;\\}\\)\\],]/)) {\n          return cont();\n        }\n      }\n\n      __name(typeprop, \"typeprop\");\n\n      function quasiType(type2, value) {\n        if (type2 != \"quasi\") return pass();\n        if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n        return cont(typeexpr, continueQuasiType);\n      }\n\n      __name(quasiType, \"quasiType\");\n\n      function continueQuasiType(type2) {\n        if (type2 == \"}\") {\n          cx.marked = \"string-2\";\n          cx.state.tokenize = tokenQuasi;\n          return cont(quasiType);\n        }\n      }\n\n      __name(continueQuasiType, \"continueQuasiType\");\n\n      function typearg(type2, value) {\n        if (type2 == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg);\n        if (type2 == \":\") return cont(typeexpr);\n        if (type2 == \"spread\") return cont(typearg);\n        return pass(typeexpr);\n      }\n\n      __name(typearg, \"typearg\");\n\n      function afterType(type2, value) {\n        if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType);\n        if (value == \"|\" || type2 == \".\" || value == \"&\") return cont(typeexpr);\n        if (type2 == \"[\") return cont(typeexpr, expect(\"]\"), afterType);\n\n        if (value == \"extends\" || value == \"implements\") {\n          cx.marked = \"keyword\";\n          return cont(typeexpr);\n        }\n\n        if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr);\n      }\n\n      __name(afterType, \"afterType\");\n\n      function maybeTypeArgs(_, value) {\n        if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType);\n      }\n\n      __name(maybeTypeArgs, \"maybeTypeArgs\");\n\n      function typeparam() {\n        return pass(typeexpr, maybeTypeDefault);\n      }\n\n      __name(typeparam, \"typeparam\");\n\n      function maybeTypeDefault(_, value) {\n        if (value == \"=\") return cont(typeexpr);\n      }\n\n      __name(maybeTypeDefault, \"maybeTypeDefault\");\n\n      function vardef(_, value) {\n        if (value == \"enum\") {\n          cx.marked = \"keyword\";\n          return cont(enumdef);\n        }\n\n        return pass(pattern, maybetype, maybeAssign, vardefCont);\n      }\n\n      __name(vardef, \"vardef\");\n\n      function pattern(type2, value) {\n        if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(pattern);\n        }\n\n        if (type2 == \"variable\") {\n          register(value);\n          return cont();\n        }\n\n        if (type2 == \"spread\") return cont(pattern);\n        if (type2 == \"[\") return contCommasep(eltpattern, \"]\");\n        if (type2 == \"{\") return contCommasep(proppattern, \"}\");\n      }\n\n      __name(pattern, \"pattern\");\n\n      function proppattern(type2, value) {\n        if (type2 == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n          register(value);\n          return cont(maybeAssign);\n        }\n\n        if (type2 == \"variable\") cx.marked = \"property\";\n        if (type2 == \"spread\") return cont(pattern);\n        if (type2 == \"}\") return pass();\n        if (type2 == \"[\") return cont(expression, expect(\"]\"), expect(\":\"), proppattern);\n        return cont(expect(\":\"), pattern, maybeAssign);\n      }\n\n      __name(proppattern, \"proppattern\");\n\n      function eltpattern() {\n        return pass(pattern, maybeAssign);\n      }\n\n      __name(eltpattern, \"eltpattern\");\n\n      function maybeAssign(_type, value) {\n        if (value == \"=\") return cont(expressionNoComma);\n      }\n\n      __name(maybeAssign, \"maybeAssign\");\n\n      function vardefCont(type2) {\n        if (type2 == \",\") return cont(vardef);\n      }\n\n      __name(vardefCont, \"vardefCont\");\n\n      function maybeelse(type2, value) {\n        if (type2 == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n      }\n\n      __name(maybeelse, \"maybeelse\");\n\n      function forspec(type2, value) {\n        if (value == \"await\") return cont(forspec);\n        if (type2 == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n      }\n\n      __name(forspec, \"forspec\");\n\n      function forspec1(type2) {\n        if (type2 == \"var\") return cont(vardef, forspec2);\n        if (type2 == \"variable\") return cont(forspec2);\n        return pass(forspec2);\n      }\n\n      __name(forspec1, \"forspec1\");\n\n      function forspec2(type2, value) {\n        if (type2 == \")\") return cont();\n        if (type2 == \";\") return cont(forspec2);\n\n        if (value == \"in\" || value == \"of\") {\n          cx.marked = \"keyword\";\n          return cont(expression, forspec2);\n        }\n\n        return pass(expression, forspec2);\n      }\n\n      __name(forspec2, \"forspec2\");\n\n      function functiondef(type2, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(functiondef);\n        }\n\n        if (type2 == \"variable\") {\n          register(value);\n          return cont(functiondef);\n        }\n\n        if (type2 == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n        if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef);\n      }\n\n      __name(functiondef, \"functiondef\");\n\n      function functiondecl(type2, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(functiondecl);\n        }\n\n        if (type2 == \"variable\") {\n          register(value);\n          return cont(functiondecl);\n        }\n\n        if (type2 == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n        if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl);\n      }\n\n      __name(functiondecl, \"functiondecl\");\n\n      function typename(type2, value) {\n        if (type2 == \"keyword\" || type2 == \"variable\") {\n          cx.marked = \"type\";\n          return cont(typename);\n        } else if (value == \"<\") {\n          return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex);\n        }\n      }\n\n      __name(typename, \"typename\");\n\n      function funarg(type2, value) {\n        if (value == \"@\") cont(expression, funarg);\n        if (type2 == \"spread\") return cont(funarg);\n\n        if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(funarg);\n        }\n\n        if (isTS && type2 == \"this\") return cont(maybetype, maybeAssign);\n        return pass(pattern, maybetype, maybeAssign);\n      }\n\n      __name(funarg, \"funarg\");\n\n      function classExpression(type2, value) {\n        if (type2 == \"variable\") return className(type2, value);\n        return classNameAfter(type2, value);\n      }\n\n      __name(classExpression, \"classExpression\");\n\n      function className(type2, value) {\n        if (type2 == \"variable\") {\n          register(value);\n          return cont(classNameAfter);\n        }\n      }\n\n      __name(className, \"className\");\n\n      function classNameAfter(type2, value) {\n        if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter);\n\n        if (value == \"extends\" || value == \"implements\" || isTS && type2 == \",\") {\n          if (value == \"implements\") cx.marked = \"keyword\";\n          return cont(isTS ? typeexpr : expression, classNameAfter);\n        }\n\n        if (type2 == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n      }\n\n      __name(classNameAfter, \"classNameAfter\");\n\n      function classBody(type2, value) {\n        if (type2 == \"async\" || type2 == \"variable\" && (value == \"static\" || value == \"get\" || value == \"set\" || isTS && isModifier(value)) && cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false)) {\n          cx.marked = \"keyword\";\n          return cont(classBody);\n        }\n\n        if (type2 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          return cont(classfield, classBody);\n        }\n\n        if (type2 == \"number\" || type2 == \"string\") return cont(classfield, classBody);\n        if (type2 == \"[\") return cont(expression, maybetype, expect(\"]\"), classfield, classBody);\n\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(classBody);\n        }\n\n        if (isTS && type2 == \"(\") return pass(functiondecl, classBody);\n        if (type2 == \";\" || type2 == \",\") return cont(classBody);\n        if (type2 == \"}\") return cont();\n        if (value == \"@\") return cont(expression, classBody);\n      }\n\n      __name(classBody, \"classBody\");\n\n      function classfield(type2, value) {\n        if (value == \"!\") return cont(classfield);\n        if (value == \"?\") return cont(classfield);\n        if (type2 == \":\") return cont(typeexpr, maybeAssign);\n        if (value == \"=\") return cont(expressionNoComma);\n        var context = cx.state.lexical.prev,\n            isInterface = context && context.info == \"interface\";\n        return pass(isInterface ? functiondecl : functiondef);\n      }\n\n      __name(classfield, \"classfield\");\n\n      function afterExport(type2, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(maybeFrom, expect(\";\"));\n        }\n\n        if (value == \"default\") {\n          cx.marked = \"keyword\";\n          return cont(expression, expect(\";\"));\n        }\n\n        if (type2 == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n        return pass(statement);\n      }\n\n      __name(afterExport, \"afterExport\");\n\n      function exportField(type2, value) {\n        if (value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(expect(\"variable\"));\n        }\n\n        if (type2 == \"variable\") return pass(expressionNoComma, exportField);\n      }\n\n      __name(exportField, \"exportField\");\n\n      function afterImport(type2) {\n        if (type2 == \"string\") return cont();\n        if (type2 == \"(\") return pass(expression);\n        if (type2 == \".\") return pass(maybeoperatorComma);\n        return pass(importSpec, maybeMoreImports, maybeFrom);\n      }\n\n      __name(afterImport, \"afterImport\");\n\n      function importSpec(type2, value) {\n        if (type2 == \"{\") return contCommasep(importSpec, \"}\");\n        if (type2 == \"variable\") register(value);\n        if (value == \"*\") cx.marked = \"keyword\";\n        return cont(maybeAs);\n      }\n\n      __name(importSpec, \"importSpec\");\n\n      function maybeMoreImports(type2) {\n        if (type2 == \",\") return cont(importSpec, maybeMoreImports);\n      }\n\n      __name(maybeMoreImports, \"maybeMoreImports\");\n\n      function maybeAs(_type, value) {\n        if (value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(importSpec);\n        }\n      }\n\n      __name(maybeAs, \"maybeAs\");\n\n      function maybeFrom(_type, value) {\n        if (value == \"from\") {\n          cx.marked = \"keyword\";\n          return cont(expression);\n        }\n      }\n\n      __name(maybeFrom, \"maybeFrom\");\n\n      function arrayLiteral(type2) {\n        if (type2 == \"]\") return cont();\n        return pass(commasep(expressionNoComma, \"]\"));\n      }\n\n      __name(arrayLiteral, \"arrayLiteral\");\n\n      function enumdef() {\n        return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex);\n      }\n\n      __name(enumdef, \"enumdef\");\n\n      function enummember() {\n        return pass(pattern, maybeAssign);\n      }\n\n      __name(enummember, \"enummember\");\n\n      function isContinuedStatement(state, textAfter) {\n        return state.lastType == \"operator\" || state.lastType == \",\" || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));\n      }\n\n      __name(isContinuedStatement, \"isContinuedStatement\");\n\n      function expressionAllowed(stream, state, backUp) {\n        return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) || state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));\n      }\n\n      __name(expressionAllowed, \"expressionAllowed\");\n\n      return {\n        startState: function startState(basecolumn) {\n          var state = {\n            tokenize: tokenBase,\n            lastType: \"sof\",\n            cc: [],\n            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n            localVars: parserConfig.localVars,\n            context: parserConfig.localVars && new Context(null, null, false),\n            indented: basecolumn || 0\n          };\n          if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\") state.globalVars = parserConfig.globalVars;\n          return state;\n        },\n        token: function token(stream, state) {\n          if (stream.sol()) {\n            if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n            state.indented = stream.indentation();\n            findFatArrow(stream, state);\n          }\n\n          if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n          var style = state.tokenize(stream, state);\n          if (type == \"comment\") return style;\n          state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n          return parseJS(state, style, type, content, stream);\n        },\n        indent: function indent(state, textAfter) {\n          if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n          if (state.tokenize != tokenBase) return 0;\n          var firstChar = textAfter && textAfter.charAt(0),\n              lexical = state.lexical,\n              top;\n          if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n            var c = state.cc[i];\n            if (c == poplex) lexical = lexical.prev;else if (c != maybeelse && c != popcontext) break;\n          }\n\n          while ((lexical.type == \"stat\" || lexical.type == \"form\") && (firstChar == \"}\" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))) {\n            lexical = lexical.prev;\n          }\n\n          if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\") lexical = lexical.prev;\n          var type2 = lexical.type,\n              closing = firstChar == type2;\n          if (type2 == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);else if (type2 == \"form\" && firstChar == \"{\") return lexical.indented;else if (type2 == \"form\") return lexical.indented + indentUnit;else if (type2 == \"stat\") return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);\n        },\n        electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n        blockCommentStart: jsonMode ? null : \"/*\",\n        blockCommentEnd: jsonMode ? null : \"*/\",\n        blockCommentContinue: jsonMode ? null : \" * \",\n        lineComment: jsonMode ? null : \"//\",\n        fold: \"brace\",\n        closeBrackets: \"()[]{}''\\\"\\\"``\",\n        helperType: jsonMode ? \"json\" : \"javascript\",\n        jsonldMode: jsonldMode,\n        jsonMode: jsonMode,\n        expressionAllowed: expressionAllowed,\n        skipExpression: function skipExpression(state) {\n          parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null));\n        }\n      };\n    });\n    CodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n    CodeMirror.defineMIME(\"text/javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/json\", {\n      name: \"javascript\",\n      json: true\n    });\n    CodeMirror.defineMIME(\"application/x-json\", {\n      name: \"javascript\",\n      json: true\n    });\n    CodeMirror.defineMIME(\"application/manifest+json\", {\n      name: \"javascript\",\n      json: true\n    });\n    CodeMirror.defineMIME(\"application/ld+json\", {\n      name: \"javascript\",\n      jsonld: true\n    });\n    CodeMirror.defineMIME(\"text/typescript\", {\n      name: \"javascript\",\n      typescript: true\n    });\n    CodeMirror.defineMIME(\"application/typescript\", {\n      name: \"javascript\",\n      typescript: true\n    });\n  });\n})();\n\nvar javascript = javascript$2.exports;\nvar javascript$1 =\n/* @__PURE__ */\nObject.freeze(\n/* @__PURE__ */\n_mergeNamespaces((_mergeNamespaces2 = {\n  __proto__: null\n}, _defineProperty(_mergeNamespaces2, Symbol.toStringTag, \"Module\"), _defineProperty(_mergeNamespaces2, \"default\", javascript), _mergeNamespaces2), [javascript$2.exports]));\nexport { javascript$1 as j };"],"sourceRoot":""}