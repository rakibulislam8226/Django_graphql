{"version":3,"sources":["../node_modules/@graphiql/react/dist/mode.es.js","../node_modules/@graphiql/react/dist/onlineParser.es.js"],"names":["__webpack_require__","r","__webpack_exports__","_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__","_index_es_js__WEBPACK_IMPORTED_MODULE_1__","_onlineParser_es_js__WEBPACK_IMPORTED_MODULE_2__","__defProp","Object","defineProperty","__name","target","value","configurable","indent","state","textAfter","_a","_b","levels","length","this","electricInput","test","indentLevel","config","indentUnit","graphqlModeFactory","parser","eatWhitespace","stream","eatWhile","lexRules","parseRules","editorConfig","tabSize","startState","token","fold","lineComment","closeBrackets","pairs","explode","defineMode","d","onlineParser","_index_es_js__WEBPACK_IMPORTED_MODULE_0__","graphql__WEBPACK_IMPORTED_MODULE_1__","options","arguments","undefined","initialState","level","step","name","kind","type","rule","needsSeparator","prevState","pushRule","DOCUMENT","getToken","inBlockstring","match","skipToEnd","popRule","needsAdvance","advanceRule","sol","Math","floor","indentation","lex","SpecialParseRules","backupState","assign","concat","slice","expected","separator","ofRule","call","update","style","unsuccessful","to","from","keys","i","Invalid","Comment","rules","ruleKind","TypeError","successful","isList","Array","isArray","kinds"],"mappings":"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","file":"static/js/18.6b145caa.chunk.js","sourcesContent":["var __defProp = Object.defineProperty;\n\nvar __name = function __name(target, value) {\n  return __defProp(target, \"name\", {\n    value: value,\n    configurable: true\n  });\n};\n\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport \"graphql\";\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { o as onlineParser } from \"./onlineParser.es.js\";\nimport \"react\";\nimport \"react-dom\";\n\nfunction indent(state, textAfter) {\n  var _a, _b;\n\n  var levels = state.levels;\n  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a = this.electricInput) === null || _a === void 0 ? void 0 : _a.test(textAfter)) ? 1 : 0);\n  return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);\n}\n\n__name(indent, \"indent\");\n\nvar graphqlModeFactory =\n/* @__PURE__ */\n__name(function (config) {\n  var parser = onlineParser({\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(isIgnored);\n    },\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: {\n      tabSize: config.tabSize\n    }\n  });\n  return {\n    config: config,\n    startState: parser.startState,\n    token: parser.token,\n    indent: indent,\n    electricInput: /^\\s*[})\\]]/,\n    fold: \"brace\",\n    lineComment: \"#\",\n    closeBrackets: {\n      pairs: '()[]{}\"\"',\n      explode: \"()[]{}\"\n    }\n  };\n}, \"graphqlModeFactory\");\n\nCodeMirror.defineMode(\"graphql\", graphqlModeFactory);","var __defProp = Object.defineProperty;\n\nvar __name = function __name(target, value) {\n  return __defProp(target, \"name\", {\n    value: value,\n    configurable: true\n  });\n};\n\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { Kind } from \"graphql\";\n\nfunction onlineParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(isIgnored);\n    },\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: {}\n  };\n  return {\n    startState: function startState() {\n      var initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeparator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token: function token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n\n__name(onlineParser, \"onlineParser\");\n\nfunction getToken(stream, state, options) {\n  var _a;\n\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n\n  var lexRules = options.lexRules,\n      parseRules = options.parseRules,\n      eatWhitespace = options.eatWhitespace,\n      editorConfig = options.editorConfig;\n\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n\n  if (stream.sol()) {\n    var tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n\n  var token = lex(lexRules, stream);\n\n  if (!token) {\n    var matchedSomething = stream.match(/\\S+/);\n\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n\n  if (token.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n\n  var backupState = assign({}, state);\n\n  if (token.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n\n  while (state.rule) {\n    var expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n\n    if (state.needsSeparator) {\n      expected = expected === null || expected === void 0 ? void 0 : expected.separator;\n    }\n\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n\n      if ((_a = expected.match) === null || _a === void 0 ? void 0 : _a.call(expected, token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n\n        if (token.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n\n        return expected.style;\n      }\n    }\n\n    unsuccessful(state);\n  }\n\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\n\n__name(getToken, \"getToken\");\n\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n\n  return to;\n}\n\n__name(assign, \"assign\");\n\nvar SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\n\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeparator = false;\n}\n\n__name(pushRule, \"pushRule\");\n\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeparator = state.prevState.needsSeparator;\n  state.prevState = state.prevState.prevState;\n}\n\n__name(popRule, \"popRule\");\n\nfunction advanceRule(state, successful) {\n  var _a;\n\n  if (isList(state) && state.rule) {\n    var step = state.rule[state.step];\n\n    if (step.separator) {\n      var separator = step.separator;\n      state.needsSeparator = !state.needsSeparator;\n\n      if (!state.needsSeparator && separator.ofRule) {\n        return;\n      }\n    }\n\n    if (successful) {\n      return;\n    }\n  }\n\n  state.needsSeparator = false;\n  state.step++;\n\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n\n    if (state.rule) {\n      if (isList(state)) {\n        if ((_a = state.rule) === null || _a === void 0 ? void 0 : _a[state.step].separator) {\n          state.needsSeparator = !state.needsSeparator;\n        }\n      } else {\n        state.needsSeparator = false;\n        state.step++;\n      }\n    }\n  }\n}\n\n__name(advanceRule, \"advanceRule\");\n\nfunction isList(state) {\n  var step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\n\n__name(isList, \"isList\");\n\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n\n__name(unsuccessful, \"unsuccessful\");\n\nfunction lex(lexRules, stream) {\n  var kinds = Object.keys(lexRules);\n\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(lexRules[kinds[i]]);\n\n    if (match && match instanceof Array) {\n      return {\n        kind: kinds[i],\n        value: match[0]\n      };\n    }\n  }\n}\n\n__name(lex, \"lex\");\n\nexport { onlineParser as o };"],"sourceRoot":""}